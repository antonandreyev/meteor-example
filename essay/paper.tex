\documentclass[a4paper,12pt]{article}

\usepackage{fontenc}
\usepackage{polyglossia}
\setdefaultlanguage{russian}
\setotherlanguage{english}
\defaultfontfeatures{Ligatures=TeX}

\setmainfont{CMU Serif}
\setsansfont{CMU Sans Serif}
\setmonofont{CMU Typewriter Text}
\newfontfamily\cyrillicfont[Script=Cyrillic]{CMU Serif}
\newfontfamily\cyrillicfontsf[Script=Cyrillic]{CMU Sans Serif}
\newfontfamily\cyrillicfonttt[Script=Cyrillic]{CMU Typewriter Text}

\tolerance=10000
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ifthen}
\usepackage{tikz}
\usepackage{indentfirst}
\usepackage{alltt}
\renewcommand{\baselinestretch}{1.5}

\begin{document}
\title{Реферат по JavaScript-фреймворку Meteor}
\author{А.~А.~Андреев, 22609}
\date{\today}
\maketitle

\large

\section*{Введение}
Трендом последних нескольких лет в Web-разработке являются приложения реального
времени и их разновидность --- реактивные приложения. Реактивность подразумевает
мгновенное обновление данных на клиентской стороне при обновлении их на сервере
(без необходимости обновлять страницу). Часто такие приложение выполняются в виде
одностраничных приложений, т.е. переходы между ресурсами приложения выполняются
без загрузки новой страницы, чаще всего с помощью асинхронной загрузки данных
с сервера. 

Закономерно, для облегчения создания таких приложений появился ряд программных
каркасов (фреймворков) для языка JavaScript, как основного языка клиентской
Web-Разработки. Некоторые из них предоставляют уровень абстракции
только для уровня представления (напрмер, ReactJS), другие предлагают
вариацию паттерна MVC (BackboneJS, AngularJS) и опирются на серверную сторону
через REST- или JSON-интерфейс.

Еще одна вариация фреймворк-архитектуры предлагается Meteor (MeteorJS). 
Этот программный каркас предлагает full stack JavaScript разработку
с NodeJS на серверной стороне. В данном реферате рассматриваются 
подробности архитектуры фреймворка Meteor, основы и тонкости создания
приложений на его основе (на примере приложения для размещения новостей).

\section{Архитектура MeteorJS}
Meteor предлагает использование одного языка -- JavaScript -- и на
клиентской стороне (web-обозреватель, web-view на мобильных платформах), и
на серверной стороне (NodeJS). При этом все API (в том числе и к базе
данных) -- нативные для этого языка.

Для общения между двумя сторонами в Meteor используется собственный протокол --
Distributed Data Protocol (DDP). Он подразумевает общение между двумя сторонами
посредством JSON-объектов и пропагандирует модель публикация-подписка,
что позволяет асинхронно получать данные при обновлении их на сервере
без необходимости постоянного опроса сервера. В рамках протокола создается
постоянное соединение между клиентской и серверной стороной и сервер посылает
обновленные данные без инициации обмена клиентом.

Кроме того, Meteor поддерживает и стандартный для других фреймворков обмен данными
посредством HTTP-сообщений.

На серверной стороне Meteor, несмотря на занятие только одного порта,
работает сразу два web-сервера: сервер DDP (на основе SockJS и технологии
Web-сокетов), который обеспечивает реактивноевзаимодействие, и сервер HTTP (на
основе API NodeJS), который обеспечивает передачу статических файлов и
обработку классических HTTP-запросов.

В качестве СУБД Meteor предлагает использовать MongoDB, для чего имеется
собственный API, интегрированный с другими компонентами фреймворка (например,
протоколом DDP). Путем установки расширений Meteor позволяет организовать 
взаимодействие с другими СУБД, такими как PostgreSQL.

Фреймворком предоставляется возможность установки пакетов расширений
с помощью собственного менеджера пакетов Atmosphere.

\section{Основы разработки с помощью Meteor на примере новостного приложения}
Для обозначения основных моментов и тонкостей разработки приложений с помощью
Meteor в данном реферате будет описан процесс разработки приложения для размещения
Новостей. Приложение будет предоставлять возможность размещения новостей
(заголовок + текст) авторизованными пользователями и чтения новостей
всеми пользователями.

\subsection{Установка Meteor}

Дистрибутив фреймворка включает в себя не только файлы самого фреймворка, 
в него интегрированы NodeJS и MongoDB, что облегчает
первоначальную настройку приложения (однако усложняет установку приложений 
на production-сервер в плане гибкости настроек). После
установки дистрибутива, соответствующего целевой операционной системе,
из коммандной строки будет доступна команда ``\$~meteor~create~имя\_приложения'',
с помощью которой происходит инициализация начальной структуры нового приложения.

Рассматриваемый фреймворк имеет также собственный менеджер пакетов по названием
Atmosphere с соответствующим репозиторием пакетов (см. \cite{X}).
Установка пакетов осуществляется с помощью команды ``\$~meteor~add~имя\_пакета'',
а удалить с помощью ``\$~meteor~remove~имя\_пакета''.

\subsection{Файловая структура приложений}

После инициализации приложения будет создана следующая файловая структура:
\begin{itemize}
	\item package.json --- файл, описывающий приложение для npm;
	\item server/main.js --- файл, являющийся точкой входа для
	всего server-side кода;
	\item client/main.js --- файл, являющийся точкой входа для
	всего client-side кода;
	\item client/main.html --- файл с описанием представления приложения,
	включая шаблоны;
	\item client/main.css --- основной файл стилей приложения;
	\item .meteor --- каталог со служебными файлами фреймворка,
	включая список зависимостей, настройки приложения и т.п.;
	\item .meteor/local --- каталог со служебными локальными файлами 
	приложения, включая файлы базы данных, установленные пакеты 
	расширений, скомпилированные js-файлы.
\end{itemize}

В Meteor поощряется использование директив import/export из спецификации
ES2015. Так, создателяи фреймворка предлагается разделять приложение
на небольшие модули и импортировать их друг из друга. Исходя из
данных рекомендаций, в Новостном приложении будет использоваться следующая
дополнительная файловая структура:

\begin{itemize}
	\item imports --- каталог с модулями приложения;
	\item imports/startup/\{client и server\} --- код, который должен выполнится
	при старте приложения на клиентской и на серверной стороне соответственно;
	\item imports/api --- модули, описывающие предметную область приложения
	и вспомогательные функции;
	\item imorts/api/accounts-config.js --- инициализация и настройка системы аккаунтов пользователей;
	\item imports/ui --- модули уровня представления, включая шаблоны (.html) 
	и инициализирующий и вспомогательный код для шаблонов (.js).
\end{itemize}

Все соответствующие файлы из каталога ``startup'' (и
других, которые требуются) должны быть
импортированы в ``client/main.js'' и ``server/main.js''.

\subsection{Работа с базой данных}
В качестве СУБД по умолчанию Meteor использует MongoDB \cite{X}. 
Данные хранятся в виде коллекций документов произвольной структуры.
Доступ к БД осуществляется через объект ``Mongo'', который подключается
следующим образом:

\begin{alltt}
import \{ Mongo \} from 'meteor/mongo';
\end{alltt}

Документы БД в Meteor представлены, как объекты JavaScript.
Работа с коллекциями осуществляется следующим образом:

\begin{alltt}
// создание
var coll = new Mongo.Collection('collection\_name'); 
// получение всех документов
coll.find();
// запрос по документам
coll.find(\{someProperty: someVal\});
// получение одного найденного документа
coll.findOne(\{someProperty: someVal\});
// вставка документа
coll.insert(\{someProperty: someVal\});
// удаление всех удовлетворяющих элементов
coll.remove(\{someProperty: someVal\});
\end{alltt}

Подробнее см. общий API MongoDB. Заметим одну особенность Meteor:
коллекции по умолчанию доступны и на стороне сервера, и на стороне
клиента. При этом, при создании коллекции на стороне сервера
данная коллекция будет создана в БД, а при создании
коллекции на стороне клиента будет создано кеширующее подключение
к коллекции на сервере. На клиенте при этом по умолчанию будут
доступны все операции CRUD.

MongoDB является NoSQL базой данных и данные в ней по умолчанию
не валидируются. Для включения проверки данных в соответствии
с некоторой схемой данных можно использовать собственный (сложный!)
механизм MongoDB или использовать валидацию на стороне приложения
перед вставкой данных. Для Meteor для этого есть, например, пакет
aldeed:simple-schema.

Определение схемы для коллекции осуществляется следующим образом:
\begin{alltt}
	import \{ SimpleSchema \} from 'meteor/aldeed:simple-schema';
	
	coll.schema = new SimpleSchema(\{...\});
\end{alltt}

Включение автоматической валидации документов при операциях
insert и update можно осуществить следующим образом:

\begin{alltt}
	coll.attachSchema(coll.schema);
\end{alltt}

При работе с некорректными данными будет выбрашено ValidationError.

Для рассматриваемого новостного приложения спроектируем единственную
требуемую коллекцию --- коллекцию новостей. Meteor предлагает размещать
файлы с описанием коллекций в ``imports/api/''. В этом каталоге
создадим файл ``News.js'' с описанием коллекции новостей.
Схема будет следующая:

\begin{alltt}
News.schema = new SimpleSchema(\{
	// идентификатор новости
    \_id: \{ type: String, regEx: SimpleSchema.RegEx.Id \},
    // заголовок новости
    title: \{ type: String \},
    // основной новостной текст новости (в виде HTML)
    text: \{ type: String \},
    // дана создания новости
    date: \{ type: Date \},
    // имя пользователя, который создал новость
    username : \{ type: String \}
\});
\end{alltt}

Чтобы сделать коллекцию доступной в других модулях
приложения, в верхней части файла добавим:

\begin{alltt}
export const News = new Mongo.Collection('News');
\end{alltt}

\subsection{Роутинг}
Meteor ориентирован на создание одностраничных приложений, для которых
не нужен роутинг. Однако, для поддержки некоторых возможностей обработка
адресной строки и перенаправления между страницами все таки необходимо.
В нашем приложении предполагается существование отдельной страницы
для каждой новости и уникального адреса для них (чтобы доступ к
отдельной новости можно было бы легко получить извне, например
для индексации в поисковых системах).

Одним из доступных роутеров (которые распространяются в виде пакетов)
является ``kadira:flow-router''.

Для определения маршрута, который будет обрабатываться приложением
(на стороне клиента!), можно использовать следующую конструкцию:

\begin{alltt}
import \{ FlowRouter \} from 'meteor/kadira:flow-router';

FlowRouter.route('/some/path/:someVariable', \{
    name: 'SomeName.show',
    action(params, queryParams) \{
        // какие-либо действия
        console.log("some log");
    \}
\});
\end{alltt}

В данном случае, при совпадении запрашиваемого адреса с
определенным адресом будут выполнены действия, определенные
в методе ``action''. Параметры адресного запроса
указываются начиная с двоеточия. Объект ``params''
будет содержать имена и значения определенных параметров 
адресной строки, а объект ``queryParams'' ---
параметров GET запроса (если есть).

Для нашего приложения потребуются два маршрута.
Маршрут для корня приложения (адрес '/') и маршрут
для отдельной новости (адрес '/post/:\_id'). 

\begin{alltt}
FlowRouter.route('/post/:\_id', \{
    name: 'Post.show',
    action() \{  
        ...
    \}
\});

FlowRouter.route('/', \{
    name: 'main.show',
    action() \{  
        ...
    \}
\});
\end{alltt}

Предполагается, что файл с описанием маршрутов будет
размещен в ``imports/startup/client'', а модуль, описываемый
файлом, будет импортирован ``client/main.js''.

\subsection{Аутентификация и авторизация}
\dots

\subsection{Шаблоны представлений}
\dots

\subsection{Дальнейшая работа}
\dots

\section*{Заключение}
\dots

\begin{thebibliography}{99}
	
\end{thebibliography}

\end{document}
